# CH6 - 실전에 활용 가능한 컨테이너 사용법을 익히자

# 1. 컨테이너와 호스트 간에 파일 복사하기

## 파일 복사

- 파일 복사는 컨테이너 → 호스트, 호스트 → 컨테이너 양방향 모두 가능하다.

### 파일 복사 커맨드 docker cp (docker container cp)

```bash
docker cp 원본_경로 복사할_경로
```

- 호스트 → 컨테이너

```bash
docker cp 호스트_경로 컨테이너_이름:컨테이너_경로
```

- 컨테이너 → 호스트

```bash
docker cp 컨테이너_이름:컨테이너_경로 호스트_경로
```

### 호스트 경로의 예

- 호스트(도커 엔진을 실행하는 컴퓨터) 내 파일 위치는 어디라도 괜찮다.
- 파일의 위치는 ‘경로’ 형태로 작성한다. 경로는 컴퓨터 속 파일이나 폴더의 주소를 나타낸 것이다.

### index.html 파일 만들기

- 아파치 컨테이너를 예로 들자.

```html
<html>
    <meta charset="utf-8"/>
    <body>
        <div>안녕하세요!</div>
    </body>
</html>
```

## 호스트의 파일을 컨테이너 속으로 복사

### 아파치 컨테이너 생성

```bash
docker run --name apa000ex19 -d -p 8089:80 httpd
```

### cp 커맨드를 실행해 호스트에서 컨테이너로 파일을 복사

```bash
docker cp /Users/sehyun/Desktop/test/index.html apa000ex19:/usr/local/apache2/htdocs/
```

## 컨테이너의 파일을 호스트로 복사

```bash
# 리눅스에서 파일명 변경하기
mv /home/사용자명/index.html /home/사용자명/index2.html
# 리눅스에서 파일 삭제하기
rm /home/사용자명/index.html
```

### cp 커맨드를 실행해 파일 복사

```bash
docker cp apa000ex19:/usr/local/apache2/htdocs/index.html /Users/sehyun/Desktop/test
```

### 실행 중인 컨테이너를 한 번에 종료하기

```bash
docker rm -f $(docker ps -qa)
```

# 2. 볼륨 마운트

## 볼륨과 마운트

- **볼륨:** 스토리지의 한 영역을 분할한 것. 간단히 말하면 하드디스크나 SSD를 분할한 하나의 영역이다.
- **마운트:** ‘연결하다’라는 의미 그대로 대상을 연결해 운영체제 또는 소프트웨어의 관리 하에 두는 일을 말한다.
    - 실제로 컨테이너를 사용하려면 스토리지 영역을 마운트해야 한다. 왜냐하면 데이터가 이 스토리지에 있기 때문이다.
    - 컨테이너를 종료해도 바로 삭제되지는 않지만 성격상 쓰고 버려야 하기 때문에 소프트웨어 업그레이드 등의 이유로 언젠가는 삭제된다.
    - 컨테이너는 생성 및 폐기가 매우 빈번하기 때문에 매번 데이터를 옮기는 대신 처음부터 컨테이너 외부에 둔 데이터에 접근해 사용하는 것이 일반적이다. 이를 `데이터 퍼시스턴시`라고 한다.
    - 스토리지 마운트라고 하면 의미가 모호하기 때문에 관례적으로 ‘볼륨 마운트’라는 용어를 사용하는데, 마운트 대상이 되는 스토리지는 볼륨 외에도 디렉토리나 파일, 메모리가 될 수 있다.

## 스토리지 마운트의 종류

### 볼륨 마운트

- 도커 엔진이 관리하는 영역 내에 만들어진 볼륨을 컨테이너에 디스크 형태로 마운트한다.
- 이름만으로 관리가 가능하므로 다루기 쉽지만 볼륨에 비해 직접 조작하기 어려우므로 ‘임시 목적의 사용’이나 ‘자주 쓰지는 않지만 지우면 안 되는 파일’을 두는 목적으로 많이 사용한다.

### 바인드 마운트

- 도커가 설치된 컴퓨터의 문서 폴더 또는 바탕화면 폴더 등 도커 엔진에서 관리하지 않는 영역의 기존 디렉토리를 컨테이너에 마운트하는 방식이다. 파일 단위로도 마운트가 가능하다.
- 자주 사용하는 파일을 두는 데 사용한다.

## 스토리지 영역을 마운트하는 커맨드

- 어느 마운트 방식을 사용하든 스토리지 마운트는 `run 커맨드의 옵션 형태`로 지정한다.
- 마운트하려는 스토리지의 경로가 컨테이너 속 특정 경로와 연결되도록 설정하는 형태이다.
    - 마치 스토리지가 컨테이너 안에 있는 것처럼 설정하는 것이다.
- 마운트 대상이 되는 컨테이너 속 위치는 컨테이너의 소프트웨어가 컨텐츠를 저장하는 경로가 되는 경우가 많다.

### 스토리지를 마운트하는 절차

- 스토리지를 마운트하려면 먼저 마운트될 스토리지를 생성해야 한다.
- 볼륨 마운트의 경우 마운트와 동시에 볼륨을 만들 수도 있지만 권장하지 않는다.

### 스토리지 영역을 만드는 방법

- 볼륨 생성(볼륨 마운트)

```bash
docker volume create 볼륨_이름
```

- 볼륨 삭제(볼륨 마운트)

```bash
docker volume rm
```

- 주요 하위 커맨드

| 커맨드 | 내용 | 주요 옵션 |
| --- | --- | --- |
| create | 볼륨 생성 | 거의 사용 x |
| inspect | 볼륨 상세정보 출력 | 거의 사용 x |
| ls | 볼륨 목록 출력 | 거의 사용 x |
| prune | 현재 마운트되지 않은 볼륨을 모두 삭제 | 거의 사용 x |
| rm | 지정한 볼륨을 삭제 | 거의 사용 x |

### 스토리지를 마운트하는 커맨드

- `-v` 옵션 뒤에 `스토리지 실제 경로` 또는 `볼륨 이름`, `컨테이너 마운트 경로` 순서대로 기재한다. 이들 경로는 콜론(:)을 사용해 구분한다.

```bash
docker run (생략) -v 볼륨 이름:컨테이너_마운트_경로 (생략)
```

- 바인드 마운트는 볼륨을 마운트하지 않지만 볼륨 마운트와 마찬가지로 -v 옵션을 사용한다.

```bash
docker run (생략) -v 스토리지_실제_경로:컨테이너_마운트_경로 (생략)
```

## [실습] 바인드 마운트해보기

### 아파치 컨테이너 실행

```bash
docker run --name apa000ex20 -d -p 8090:80 -v /Users/sehyun/Desktop/test:/usr/local/apache2/htdocs httpd
```

## [실습] 볼륨 마운트해보기

### 마운트할 볼륨 생성

- 볼륨이 생성될 위치는 도커 엔진에서 관리하기 때문에 신경쓰지 않아도 된다.

```bash
docker volume create apa000vol1
```

### 아파치 컨테이너 실행

```bash
docker run --name apa000ex21 -d -p 8091:80 -v apa000vol1:/usr/local/apache2/htdocs httpd
```

### 볼륨의 상세 정보 확인

```bash
docker volume inspect apa000vol1
docker container inspect apa000ex21
```

### 볼륨 목록 보기

```bash
docker volume ls
```

### 도커 볼륨 삭제

```bash
# 특정 볼륨 삭제
docker volume rm 볼륨이름
# 사용하지 않는 볼륨을 한꺼번에 삭제
docker volume prune
```

## 볼륨 백업

- 바인드 마운트와 달리 볼륨 마운트는 백업이 까다롭다.
- 볼륨 자체를 복사할 수는 없으므로 볼륨을 확인할 때처럼 별도의 리눅스 컨테이너를 연결해 볼륨의 내용을 압축해 저장한다.
- 다만 주의할 점은 컨테이너 생성(run)과 함께 tar 명령어로 백업을 수행한다.
- 그리고 압축 파일을 컨테이너 밖에 저장해야 한다.

```bash
docker run --rm (옵션) busybox (인자)
# 예시
docker run --rm -v 볼륨명:/moto -v 백업_저장_폴더명:/target busybox tar cvzf /sake/백업파일이름.tar.gz -C /source .
```

- run 커맨드로 리눅스(busybox) 컨테이너를 실행한다. 이 컨테이너는 실행 후 바로 삭제할 예정이므로  --rm을 추가했다.
- 설정값을 채워 완성한 명령어

```bash
docker run --rm -v apa000vol1:/source -v /Users/sehyun/Desktop/test:/target busybox tar czvf /target/backup_apa.tar.gz -C /source .
```

- 복원

```bash
docker run --rm -v apa000vol2:/source -v /Users/sehyun/Desktop/test:/target busybox tar xzvf /target/backup_apa.tar.gz -C /source .
```

# 3. 컨테이너로 이미지 만들기

## 컨테이너로 이미지를 만드는 방법

- 이미 존재하는 컨테이너를 이용하면 쉽게 이미지를 만들 수 있다.
- 나만의 이미지를 만들어 똑같은 구성의 컨테이너를 대량으로 만들 수 있고, 다른 컴퓨터 또는 서버에 이동시킬 숟 있다.
- 이미지를 만드는 방법은 두 가지가 있다.
    - commit 커맨드로 기존 컨테이너를 이미지로 변환
    - Dockerfile 스크립트로 이미지 만들기

### commit 커맨드로 기존 컨테이너를 이미지로 변환

- 컨테이너만 있으면 명령어 한 번으로 이미지를 만들 수 있어 간편하지만 컨테이너를 먼저 만들어야 한다.
- 기존 컨테이너를 복제하거나 이동해야 할 때 편리하다.

```bash
docker commit 컨테이너_이름 새로운_이미지_이름
```

### Dockerfile 스크립트로 이미지 만들기

- Dockerfile 스크립트를 작성하고 이 스크립트를 빌드해 이미지를 만드는 방법이다.
- Dockerfile은 이미지를 만드는 것밖에 할 수 없다.
- Dockerfile 스크립트에는 토대가 될 이미지나 실행할 명령어 등을 기재한다.
- 이 파일을 호스트 컴퓨터의 토대가 되는 이미지가 들어있는 폴더에 넣는다. 이 폴더에는 그 외 컨테이너에 넣을 파일을 함께 둔다.
    - 실제 컨테이너를 만들 필요는 없다.

```bash
docker build -t 생성할_이미지_이름 폴더_경로
```

```docker
FROM 이미지_이름
COPY 원본_경로 대상_경로
RUN 리눅스_명령어
...
```

- 주요 Dockerfile 명령어

| 명령어 | 내용 |
| --- | --- |
| FROM | 토대가 되는 이미지를 지정 |
| ADD | 이미지에 파일이나 폴더를 추가 |
| COPY | 이미지에 파일이나 폴더를 추가 |
| RUN | 이미지를 빌드할 때 실행할 명령어를 지정 |
| CMD | 컨테이너를 실행할 때 실행할 명령어를 지정 |
| ENTRYPOINT | 컨테이너를 실행할 때 실행할 명령어를 강제 지정 |
| EXPOSE | 이미지가 통신에 사용할 포트를 명시적으로 지정 |
| VOLUME | 퍼시스턴시 데이터를 저장할 경로를 명시적으로 지정 |

## [실습] commit 커맨드로 기존 컨테이너를 이미지로 변환

### 0. 아파치 컨테이너 준비

```bash
docker run --name apa000ex22 -d -p 8092:80 httpd
```

### 1. 컨테이너를 변환한 새로운 이미지 생성

```bash
docker commit apa000ex22 ex22_original1
```

### 2. 이미지 생성 확인

```bash
docker image ls 
```

<img width="518" alt="Untitled" src="https://github.com/shkum0330/Study/assets/102662024/95b725f9-17c4-4a77-9c48-f3247a4289b5">

## [실습] Dockerfile 스크립트로 이미지 만들기

### 1. Dockerfile 스크립트 작성

```docker
FROM httpd
COPY index.html /usr/local/apache2/htdocs
```

### build 커맨드로 빌드

```bash
docker build -t ex22_original2 /Users/sehyun/apa_folder
```

# 5. 컨테이너 개조

### 컨테이너를 개조하는 방법

- 파일 복사와 마운트 이용
- 컨테이너에서 리눅스 명령어 실행

### 컨테이너에서 명령어를 실행하려면 셸이 필요하다

- **shell(셸):** 리눅스에 명령을 전달해 주는 프로그램
    - 대부분의 컨테이너에는 가장 일반적으로 사용되는 셸인 **bash**가 설치되어 있다.
- bash를 실행하는 인자: `/bin/bash`
    - 이 인자는 docker run 또는 docker exec 커맨드와 함께 사용한다.
- docker exec는 컨테이너 속에서 명령하는 커맨드다.
    - 실행 중인 컨테이너에 run 커맨드를 사용할 수 없기 때문이다.
    - 이 방법으로 bash 없이도 어느 정도 명령을 직접 전달할 수 있다.
        - 하지만 초기 설정이 없어 동작하지 않는 경우도 있어 기본적으로는 셸을 통해 명령어를 실행한다.
- docker run 커맨드에 인자를 붙였다면 상황이 조금 복잡해진다.
    - 이 경우 컨테이너에 들어있는 소프트웨어를 실행하는 대신 bash가 실행되므로 컨테이너는 실행 중인데 소프트웨어는 실행 중이 아닌 상태가 된다.
- bash를 사용한 컨테이너 조작이 끝나고 나면 다시 `docker start` 커맨드로 컨테이너를 재시작해야 한다.
- 이런 상황에는 docker run 커맨드는 잘 사용하지 않으므로 `docker exec` 커맨드만 기억해두면 된다.
- exec 커맨드에 인자를 추가한 예
    - docker exec (옵션) 컨테이너_이름 /bin/bash
- bash가 실행되면 셸에 입력된 명령어는 도커 엔진이 아니라 해당 컨테이너로 전달된다.
- 도커 컨테이너와 도커 엔진은 별개의 존재이다.
    - 따라서 **bash를 통해 컨테이너 내부를 조작하는 동안에는 도커 명령을 사용할 수 없다.** 현재 조작 중인 컨테이너라도 이 점은 마찬가지다.
- 컨테이너 안에서 할 일을 마쳤다면 다시 컨테이너에서 나와야 한다.
    - 컨테이너에서 돌아가려면 `exit` 명령어를 사용한다.

## 도커의 구조, 도커 엔진을 통해야 하는 명령과 컨테이너 안에서 실행해야 하는 명령

### 도커 엔진을 통한 명령과 컨테이너 안에서 실행해야 하는 명령

- 도커 엔진 자체의 시작 또는 종료, 네트워크, 디스크 설정, 실행 중인 컨테이너 목록 확인 등 **컨테이너 전체에 대한 관리 작업**이다.
- 컨테이너 내부에서 실행하는 명령은 컨테이너 속에 새로운 소프트웨어를 추가하거나, 컨테이너 속 소프트웨어의 실행 및 종료, 설정 변경, 컨테이너 안과 밖의 파일 복사 및 이동, 삭제 작업이다.

### 도커와 컨테이너는 별개의 언어를 사용한다

- 도커를 설치하는 명령은 윈도우와 리눅스에서 그 문법이 서로 다르다.
    - 리눅스에는 배포판 간의 차이도 존재한다. 특히 설치 명령어에는 레드햇 계열과 데비안 계열에서 큰 차이가 있다.
- 이것이 컨테이너와 어떤 관계가 있냐면 컨테이너에 있는 ‘운영체제 비슷한 것’의 종류가 무엇이냐에 따라 컨테이너 내부에서 사용하는 명령어가 약간씩 달라지게 된다.
- 도커에서 공식적으로 “특별한 이유가 없다면 데비안 계열을 기반으로 하는 것이 좋다”고 명확히 방침을 밝히고 있으므로 대부분의 컨테이너는 데비안 계열이다.
    - 가벼워야 하는 컨테이너에는 알파인 리눅스를 주로 사용한다.

# 6. 도커 허브 등록 및 로그인

## 이미지는 어디서 내려받는 걸까?

- docker run 커맨드를 사용할때 내려받는 이미지는 도커 허브에 저장된 것이다.
- 직접 만든 이미지도 도커 허브에 올릴 수 있으며, 비공개로 사용하는 도커 허브 같은 장소도 만들 수 있다.

## 도커 허브와 도커 레지스트리

- 이미지를 배포하는 장소를 **도커 레지스트리**라고 한다.
- 도커 허브는 **도커 제작사에서 운영하는 공식 도커 레지스트리이다**.

### 레지스트리와 리포지토리

- **레지스트리:** 이미지를 배포하는 장소
- **리포지토리:** 레지스트리를 구성하는 단위
    - 도커 허브에서는 리포지토리가 각각 ID를 갖게 된다.
    - 도커 허브는 각각의 회사나 개인이 가진 레지스트리가 여럿 모인 형태가 된다.

## 태그와 이미지 업로드

- 도커 허브에 이미지를 업로드하려면 이미지에 태그를 부여해야 한다.

### 이미지 이름과 태그

- 도커의 태그는 레지스트리에 업로드를 상정한 이미지 이름에 가깝다.
- `레지스트리_주소(도커 허브는 ID)/리포지토리_이름:버전`의 형식을 띤다.
    - 버전은 생략 가능하지만 붙이는 것이 좋다.

### 이미지에 태그를 부여해 복제하는 커맨드 docker tag(docker image tag)

- 원래 있던 이미지 이름을 태그로 바꾸고 이미지를 복제하라는 의미다.
- 명령어 실행 후 image ls 커맨드로 이미지 목록을 확인해 보면 원래 이미지와 태그가 부여된 이미지 둘 다 존재한다.
    - 이들의 이미지 ID는 동일하지만 별개의 이미지로 취급되므로 이미지를 삭제할 때는 두 가지 모두 삭제해야 한다.

```bash
docker tag 원래_이미지_이름 레지스트리_주소/리포지토리_이름:버전
```

### 이미지를 업로드하는 커맨드 docker push(docker image push)

- 도커 엔진은 태그에 포함된 레지스트리 주소의 도메인에 있는 레지스트리로 업로드를 시도한다.
- 리포지토리는 처음 업로드할 때는 존재하지 않는다. push 커맨드를 실행하며 만들어진다.
- 업로드 대상 레지스트리에 따라 로그인을 요구하는 경우도 있다.

```bash
docker push 레지스트리_주소/리포지토리_이름:버전
```

## 레지스트리를 만드는 방법

### 비공개 레지스트리를 만드는 방법

- 레지스트리용 컨테이너(registry)가 따로 있으므로 이를 사용하면 된다.
    - 다시 말해, 레지스트리도 도커를 통해 운영할 수 있다.
- 컨테이너를 만들면 사용자는 레지스트리에 로그인한 다음 이미지를 내려받을 곳으로 이 레지스트리를 지정한다.
- 레지스트리는 5000번 포트를 사용한다.

```bash
docker run -d -p 5000:5000: registry
```

### 도커 허브 사용

- [https://hub.docker.com/](https://hub.docker.com/)
- 도커 허브에 이미지를 업로드하면 전 세계 사람들에게 이미지를 배포할 수 있으며, 비공개 설정을 하면 이미지를 공개하지 않을 수도 있다. 이런 경우에는 미리 리포지토리를 만들어 두도록 한다.
- push 커맨드로 리포지토리를 만들면 자동으로 공개 상태(public)가 된다.
